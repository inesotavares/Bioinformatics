### HEADER

# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# @@@@@@@   Bioinformatics --- Group Assignment 2  @@@@@@@
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# @@@ By:   -> Bruna Rocha (up201906417 M:CC)          @@@
# @@@       -> InÃªs Tavares (up201706579 M:DS)         @@@
# @@@       -> Nuno Oliveira (up201703852 M:BBC)       @@@
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

import requests as req
import sys
from Bio import SeqIO, AlignIO
from Bio.Blast import NCBIWWW, NCBIXML
import re
import subprocess
from Bio import Phylo
from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor

### 1. Data Collection

def uniprot_to_fasta(uniprotID: str, seq_file: str) -> None:
    """Retrieves a protein sequence from the UniProtKB and writes it to a FASTA file."""
    # get FASTA data
    fastaURL = f"https://rest.uniprot.org/uniprotkb/{uniprotID}.fasta"
    fastaData = req.post(fastaURL).text
    # conditioned execution
    if fastaData.startswith(">"):
        # write file
        print("Retrieving the requested FASTA data...")
        with open(seq_file, "w") as fasta_file:
            fasta_file.write(fastaData)
    else:
        print(f"WARNING: {uniprotID} is NOT a valid UniProt Accession.\nPlease correct your input.")
        sys.exit()


def get_uniprot_info(uniprotID: str) -> None:
    """Writes information about a UniProt entry to a text file.
    The information to be written is customizable."""
    # the dict with the info to retrieve:
    # this can be customized!
    payload = {"query": f"accession:{uniprotID}", "format": "tsv",
               "fields": "protein_name,organism_name,cc_function,keyword"}
    # get info
    infoURL = "https://rest.uniprot.org/uniprotkb/search"
    info = req.get(infoURL, params=payload).text
    # write info
    ls = info.split("\n")
    ks = ls[0].split("\t")
    vs = ls[1].split("\t")
    infoDict = {}
    for i, k in enumerate(ks):
        infoDict.setdefault(k, vs[i])
    with open("sequence_info.txt", "w") as info_file:
        info_file.write(f"Selected information about ENTRY: {uniprotID}\n")
        for k, v in infoDict.items():
            if v:
                info_file.write(f"- {k} => {v}\n")
            else:
                info_file.write(f"- {k} => UNDEFINED\n")
            info_file.write("\n")


### 2. BLAST Analysis

def run_blast() -> None:
    """Runs BLAST over the query sequence and writes results to a XML file."""
    record = SeqIO.read("sequence.fasta", format="fasta")
    # "blastp" -> protein BLAST // "nr" -> non-redundant protein DataBase
    # param "hitlist_size" used because there are too many results for "Homo sapiens"
    blast_res = NCBIWWW.qblast("blastp", "nr", record.seq, hitlist_size=110)
    with open("blast_results.xml", "w") as blast_out:
        blast_out.write(blast_res.read())


def filter_blast_to_fasta(seqs_file: str) -> None:
    """Reads a XML file to a BLAST record object and applies customizable filters.
    Writes the filtered sequences to a FASTA-formatted file."""
    results = open("blast_results.xml")
    blast_record = NCBIXML.read(results)
    ### Our Filters:
    # ===> 10 results -> 1 species per result
    # ===> Know the species without ambiguity:
    # -> "Homo sapiens" not allowed
    # -> Exclude synthetic constructs AND predicted structures
    # -> Exclude entries with more than 1 species on the title
    # ===> Check for entries about "Hemoglobin"
    filt_res = {}
    for align in blast_record.alignments:
        if ("Homo sapiens" not in align.title) and ("synthetic construct" not in align.title) \
        and (align.title.count("[") == 1) and ("PREDICTED" not in align.title) and (re.search("hemoglobin", align.title, re.IGNORECASE)):
            for hsp in align.hsps:
                mo = re.search("(?<=[[]).*", align.title)
                if mo.group() not in "".join(filt_res.keys()):
                    filt_res.setdefault(f">{align.title}", [hsp.sbjct[i:i+60] for i in range(0, len(hsp.sbjct), 60)])
            if len(filt_res) == 10:
                break
    # write FASTA file
    with open(seqs_file, "w") as seqs:
        for header, split_seq in filt_res.items():
            seqs.write(f"{header}\n")
            for seq_part in split_seq:
                seqs.write(f"{seq_part}\n")
            seqs.write("\n")


def report_filtered_blast() -> None:
    """Creates a text file with detailed information about the results generated by
    the function 'filter_blast_to_fasta()'.
    (Based on the Biopython tutorial. The results are ordered by E_value.)"""
    results = open("blast_results.xml")
    blast_record = NCBIXML.read(results)
    with open("filtered_blast_data.txt", "w") as info_file:
        info_file.write("Here are all the results that respect our filters and do not raise ambiguities.\n")
        info_file.write("The TOP-10 alignments match the 10 sequences written to the FASTA file.\n")
        info_file.write("(Considering the best entry for each species!)\n")
        info_file.write("NOTES: > Showing the 1st 80 letters of each alignment as an example.\n")
        info_file.write("       > The results are ordered by E_value!\n")
        info_file.write("\n")
        for align in blast_record.alignments:
            if ("Homo sapiens" not in align.title) and ("synthetic construct" not in align.title) \
            and (align.title.count("[") == 1) and ("PREDICTED" not in align.title) and (re.search("hemoglobin", align.title, re.IGNORECASE)):
                for hsp in align.hsps:
                    info_file.write("***Alignment***\n")
                    info_file.write(f"-> Sequence: {align.hit_def}\n")
                    info_file.write(f"-> Length: {align.length}\n")
                    info_file.write(f"-> E_value: {hsp.expect}\n")
                    info_file.write(f"-> Query: {hsp.query[0:80]}...\n")
                    info_file.write(f"-> Match: {hsp.match[0:80]}...\n")
                    info_file.write(f"-> Sbjct: {hsp.sbjct[0:80]}...\n")
                    info_file.write("\n")


### 3. Multiple Sequence Alignment

def merge(one_sequence: str, ten_sequence: str, all_sequences: str) -> None:
    """Writes FASTA file with the merged FASTA data of tasks 1 and 2."""
    records_file1 = list(SeqIO.parse(one_sequence, "fasta"))
    records_file2 = list(SeqIO.parse(ten_sequence, "fasta"))
    merged_records = records_file1 + records_file2    
    with open(all_sequences, "w") as output_handle:
        SeqIO.write(merged_records, output_handle, "fasta")


def fasta_to_txt(fasta_file: str, txt_file: str) -> None:
    """Converts a FASTA file to a plain text file."""
    with open(fasta_file, 'r') as fasta:
        with open(txt_file, 'w') as txt:
            for line in fasta:
                    txt.write(f"{line.strip()}\n")


def msa(all_seqs: str) -> None:
    """Performs an MSA using sequences from a FASTA file."""
    # Clustal Omega via subprocess
    infile = all_seqs
    outfile = "output.fasta"
    txtfile = "alignment.txt"
    clustalo_exe = "C:/Program Files/clustalo/clustalo.exe"  # path to executable (user-dependent)
    cmd = f"{clustalo_exe} -i {infile} -o {outfile} --force"  # command to run
    try:
        subprocess.run(cmd, check=True, text=True)
    except subprocess.CalledProcessError as err:
        print(f"ERROR => {err}")
    fasta_to_txt(outfile, txtfile)


### 4. Phylogenetic tree

def phylo_tree() -> None:
    """Function to build and plot trees."""
    alignment = AlignIO.read("output.fasta", "fasta")
    calculator = DistanceCalculator('identity')
    dm = calculator.get_distance(alignment)
    construct = DistanceTreeConstructor()
    tree = construct.upgma(dm)
    # Colouring branches (from previous knowledge of the result!)
    tree.root.color = "gray"
    tree.clade[0, 1].color = "green"
    tree.clade[1, 1, 0].color = "red"
    tree.clade[1, 1, 1].color = "blue"
    ### Draw the tree -> rooted phylogram
    Phylo.draw(tree, branch_labels=lambda c: round(c.branch_length, 3))


### Outputs
if __name__ == "__main__":
    # Process interaction with the arguments
    if len(sys.argv) != 2:
        print("USAGE: python build_phylotree.py <UNIPROT_ACCESSION>")
        sys.exit()
    else:
        ### task 1
        uniprotID = sys.argv[1]
        print(f"Your query: {uniprotID}")
        print("Searching UniProtKB...")
        one_sequence = "sequence.fasta"
        uniprot_to_fasta(uniprotID, one_sequence)
        print("(Selected information regarding your query will be saved to a text file.)")
        get_uniprot_info(uniprotID)
        print("DONE\n")
        ### task 2
        print("Running BLAST with your sequence...")
        run_blast()
        print("DONE\n")
        print("Applying desired filters and writing FASTA-formatted file...")
        ten_sequences = "sequences_to_analyse.fasta"
        filter_blast_to_fasta(ten_sequences)
        print("(Information regarding these results will be saved to a text file.)")
        report_filtered_blast()
        print("DONE\n")
        ### task 3
        print("Starting the MSA...")
        all_seqs = "11seqs.fasta"
        merge(one_sequence, ten_sequences, all_seqs)
        msa(all_seqs)
        print("Saving results...")
        print("DONE\n")
        ### task 4
        print("Building and plotting the tree...")
        phylo_tree()
        print("DONE\n")
        
