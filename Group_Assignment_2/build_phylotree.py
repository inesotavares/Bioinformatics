### HEADER

# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# @@@@@@@   Bioinformatics --- Group Assignment 2  @@@@@@@
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# @@@ By:   -> Bruna Rocha (up201906417 M:CC)          @@@
# @@@       -> InÃªs Tavares (up201706579 M:DS)         @@@
# @@@       -> Nuno Oliveira (up201703852 M:BBC)       @@@
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

import requests as req
import sys
from Bio import SeqIO, AlignIO
from Bio.Blast import NCBIWWW, NCBIXML
import re
import subprocess
from Bio.Align.Applications import ClustalOmegaCommandline
from Bio import Phylo
from Bio.Phylo.TreeConstruction import DistanceCalculator, DistanceTreeConstructor
import pydot

### 1. Data Collection

def uniprot_to_fasta(uniprotID: str, sequence) -> None:
    """Retrieves a protein sequence from the UniProtKB and writes it to a FASTA file."""
    # get FASTA data
    fastaURL = f"https://rest.uniprot.org/uniprotkb/{uniprotID}.fasta"
    fastaData = req.post(fastaURL).text
    # conditioned execution
    if fastaData.startswith(">"):
        # write file
        print("Retrieving the requested FASTA data...")
        with open(sequence, "w") as fasta_file:
            fasta_file.write(fastaData)
    else:
        print(f"WARNING: {uniprotID} is NOT a valid UniProt Accession.\nPlease correct your input.")
        sys.exit()


def get_uniprot_info(uniprotID: str) -> None:
    """Writes information about a UniProt entry to a text file.
    The information to be written is customizable."""
    # the dict with the info to retrieve:
    # this can be customized!
    payload = {"query": f"accession:{uniprotID}", "format": "tsv",
               "fields": "protein_name,organism_name,cc_function,keyword"}
    # get info
    infoURL = "https://rest.uniprot.org/uniprotkb/search"
    info = req.get(infoURL, params=payload).text
    # write info
    ls = info.split("\n")
    ks = ls[0].split("\t")
    vs = ls[1].split("\t")
    infoDict = {}
    for i, k in enumerate(ks):
        infoDict.setdefault(k, vs[i])
    with open("sequence_info.txt", "w") as info_file:
        info_file.write(f"Selected information about ENTRY: {uniprotID}\n")
        for k, v in infoDict.items():
            if v:
                info_file.write(f"- {k} => {v}\n")
            else:
                info_file.write(f"- {k} => UNDEFINED\n")
            info_file.write("\n")


### 2. BLAST Analysis

def run_blast() -> None:
    """Runs BLAST over the query sequence and writes results to a XML file."""
    record = SeqIO.read("sequence.fasta", format="fasta")
    # "blastp" -> protein BLAST // "nr" -> non-redundant protein DataBase
    # param "hitlist_size" used because there are too many results for "Homo sapiens"
    blast_res = NCBIWWW.qblast("blastp", "nr", record.seq, hitlist_size=110)
    with open("blast_results.xml", "w") as blast_out:
        blast_out.write(blast_res.read())


def filter_blast_to_fasta(ten_sequence) -> None:
    """Reads a XML file to a BLAST record object and applies customizable filters.
    Writes the filtered sequences to a FASTA-formatted file."""
    results = open("blast_results.xml")
    blast_record = NCBIXML.read(results)
    ### Our Filters:
    # ===> 10 results -> 1 species per result
    # ===> Know the species without ambiguity:
    # -> "Homo sapiens" not allowed
    # -> Exclude synthetic constructs AND predicted structures
    # -> Exclude entries with more than 1 species on the title
    # ===> Check for entries about "Hemoglobin"
    filt_res = {}
    for align in blast_record.alignments:
        if ("Homo sapiens" not in align.title) and ("synthetic construct" not in align.title) \
        and (align.title.count("[") == 1) and ("PREDICTED" not in align.title) and (re.search("hemoglobin", align.title, re.IGNORECASE)):
            for hsp in align.hsps:
                mo = re.search("(?<=[[]).*", align.title)
                if mo.group() not in "".join(filt_res.keys()):
                    filt_res.setdefault(f">{align.title}", [hsp.sbjct[i:i+60] for i in range(0, len(hsp.sbjct), 60)])
            if len(filt_res) == 10:
                break
    # write FASTA file
    with open(ten_sequence, "w") as seqs:
        for header, split_seq in filt_res.items():
            seqs.write(f"{header}\n")
            for seq_part in split_seq:
                seqs.write(f"{seq_part}\n")
            seqs.write("\n")


def report_filtered_blast() -> None:
    """Creates a text file with detailed information about the results generated by
    the function 'filter_blast_to_fasta()'.
    (Based on the Biopython tutorial. The results are ordered by E_value.)"""
    results = open("blast_results.xml")
    blast_record = NCBIXML.read(results)
    with open("filtered_blast_data.txt", "w") as info_file:
        info_file.write("Here are all the results that respect our filters and do not raise ambiguities.\n")
        info_file.write("The TOP-10 alignments match the 10 sequences written to the FASTA file.\n")
        info_file.write("(Considering the best entry for each species!)\n")
        info_file.write("NOTES: > Showing the 1st 80 letters of each alignment as an example.\n")
        info_file.write("       > The results are ordered by E_value!\n")
        info_file.write("\n")
        for align in blast_record.alignments:
            if ("Homo sapiens" not in align.title) and ("synthetic construct" not in align.title) \
            and (align.title.count("[") == 1) and ("PREDICTED" not in align.title) and (re.search("hemoglobin", align.title, re.IGNORECASE)):
                for hsp in align.hsps:
                    info_file.write("***Alignment***\n")
                    info_file.write(f"-> Sequence: {align.hit_def}\n")
                    info_file.write(f"-> Length: {align.length}\n")
                    info_file.write(f"-> E_value: {hsp.expect}\n")
                    info_file.write(f"-> Query: {hsp.query[0:80]}...\n")
                    info_file.write(f"-> Match: {hsp.match[0:80]}...\n")
                    info_file.write(f"-> Sbjct: {hsp.sbjct[0:80]}...\n")
                    info_file.write("\n")


### 3. Multiple Sequence Alignment

def merge(one_sequence, ten_sequence, all_sequences):
    records_file1 = list(SeqIO.parse(one_sequence, "fasta"))
    records_file2 = list(SeqIO.parse(ten_sequence, "fasta"))
    merged_records = records_file1 + records_file2
    with open(all_sequences, "w") as output_handle:
        SeqIO.write(merged_records, output_handle, "fasta")

def fasta_to_txt(fasta_file, txt_file):
    with open(fasta_file, 'r') as fasta:
        with open(txt_file, 'w') as txt:
            for line in fasta:
                txt.write(f"{line.strip()}\n")

def msa(eleven_sequence):
    input_file = eleven_sequence
    output_file = "output.fasta"
    txt_file = "alignment.txt"

    clustalomega_cline = ClustalOmegaCommandline(infile=input_file, outfile=output_file, verbose=True, auto=True)

    # Clustal Omega via subprocess
    try:
        subprocess.run(str(clustalomega_cline), shell=True, check=True)
    except subprocess.CalledProcessError as err:
        print(f"ERROR => {err}")
    
    fasta_to_txt(output_file, txt_file)

### 4. Phylogenetic tree

def phy_tree(file):
    alignment = AlignIO.read(file, "fasta")

    calculator = DistanceCalculator('identity')
    dm = calculator.get_distance(alignment)
    
    constructor = DistanceTreeConstructor()
    tree = constructor.upgma(dm)

    # Colouring branches (from previous knowledge of the result!)
    tree.root.color = "gray"
    tree.clade[0, 1].color = "green"
    tree.clade[1, 1, 0].color = "red"
    tree.clade[1, 1, 1].color = "blue"

    # Draw the tree, phylo
    Phylo.draw(tree, branch_labels=lambda c: round(c.branch_length, 3))

def add_clades(clade, parent=None):
    node_id = str(clade)
    if clade.is_terminal():  # It's a leaf node
        node_color = 'yellow'
    else:  # It's an inner node
        node_color = 'lightblue'

    if node_id not in nodes:
        # Node style, shape, and label orientation
        nodes[node_id] = pydot.Node(node_id, label=node_id, shape='ellipse', style='filled', fillcolor=node_color, orientation='90')
        graph.add_node(nodes[node_id])

    if parent:
        edge_weight = round(clade.branch_length or 0.1, 3)  
        graph.add_edge(pydot.Edge(nodes[str(parent)], nodes[node_id], label=f"{edge_weight}"))

    for child in clade.clades:
        add_clades(child, clade)

def tree_to_pydot(tree):
    global graph, nodes
    # dot graph with left-to-right 
    graph = pydot.Dot(graph_type='digraph', layout='dot', rankdir='LR')
    nodes = {} 
    add_clades(tree.root)

    return graph

def phylo_tree1():
    alignment = AlignIO.read("output.fasta", "fasta")

    calculator = DistanceCalculator('identity')
    distance_matrix = calculator.get_distance(alignment)

    constructor = DistanceTreeConstructor()
    tree = constructor.upgma(distance_matrix)

    pydot_graph = tree_to_pydot(tree)
    # Outputs the tree as a PNG image
    pydot_graph.write_png('phylogenetic_tree.png') 
    
### Outputs
if __name__ == "__main__":
    # Process interaction with the arguments
    if len(sys.argv) != 2:
        print("USAGE: python build_phylotree.py <UNIPROT_ACCESSION>")
        sys.exit()
    else:
        # task 1
        uniprotID = sys.argv[1]
        print(f"Your query: {uniprotID}")
        print("Searching UniProtKB...")
        one_sequence = "sequence.fasta"
        uniprot_to_fasta(uniprotID, one_sequence)
        print("(Selected information regarding your query will be saved to a text file.)")
        get_uniprot_info(uniprotID)
        print("DONE\n")
        # task 2
        print("Running BLAST with your sequence...")
        run_blast()
        print("DONE\n")
        print("Applying desired filters and writing FASTA-formatted file...")
        ten_sequence = "sequences_to_analyse.fasta"
        filter_blast_to_fasta(ten_sequence)
        print("(Information regarding these results will be saved to a text file.)")
        report_filtered_blast()
        print("DONE\n")
        # task 3
        one_sequence = "sequence.fasta"
        ten_sequence = "sequences_to_analyse.fasta"
        all_sequences = "eleven_sequences.fasta"
        print("Multiple Sequence Alignment...")
        merge(one_sequence, ten_sequence, all_sequences)
        msa(all_sequences)
        print("DONE\n")
        # task 4
        file = "output.fasta"
        print("Phylogenetic tree...")
        phy_tree(file)
        phylo_tree1()
        print("DONE\n")
    
